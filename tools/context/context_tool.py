import os
from core.base_tool import BaseTool

class ContextTool(BaseTool):
    @property
    def name(self) -> str:
        return "context_manager"

    def setup(self):
        """Does not require technical initialization of external resources."""
        pass

    def get_interface_description(self) -> str:
        return "Automatically generates the AI_CONTEXT.md manifest that serves as a technical manual for AI."

    def on_boot_complete(self, container):
        """Generates the manifest using the Core's internal Registry."""
        
        # The registry is now a GUARANTEE in the container (Core)
        registry = container.registry
        
        # 1. Header and Architecture Rules
        manifest = "# ðŸ“œ SYSTEM MANIFEST FOR AI AGENT\n\n"
        manifest += "> **NOTICE:** This file is auto-generated by the Kernel. Do not edit manually.\n\n"
        
        manifest += "## ðŸ—ï¸ Philosophy and Execution Architecture\n"
        manifest += "MicroCoreOS is a modular, asynchronous, and resilient system based on Clean Architecture principles.\n\n"
        manifest += "- **Resilient Core**: The Kernel and Container are the stable heart. Plugin failures don't stop the system.\n"
        manifest += "- **Native Registry**: The system inventory is now part of the Core, ensuring total observability.\n"
        manifest += "- **Threading Model**: Plugins start in independent threads. The Kernel uses `RLock` for thread safety.\n"
        manifest += "- **Concurrency Control**: The `event_bus` uses a `ThreadPoolExecutor` for efficient event handling.\n"
        manifest += "- **Dependency Injection**: Plugins receive tools in the constructor. **Always check the 'Tools' section for method signatures.**\n\n"

        manifest += "## ðŸš€ Execution and Development\n"
        manifest += "- **Command**: Use `uv run main.py`. Do not use `python main.py` directly.\n"
        manifest += "- **Pydantic**: Pass your models to `http_server.add_endpoint` to auto-generate Swagger.\n\n"
        
        manifest += "---\n\n"

        # 2. Dynamic Tool Listing
        manifest += "## ðŸ› ï¸ Available Tools\n"
        manifest += "Automatically injected by the Kernel. **You must request them in your `__init__`** using the tool name as a parameter.\n\n"
        
        for name in container.list_tools():
            tool = container.get(name)
            health = container.get_health(name)
            status_emoji = "âœ…" if health["status"] == "OK" else "âŒ"
            
            manifest += f"### ðŸ”§ Tool: `{name}` (Status: {status_emoji} {health['status']})\n"
            if health["status"] != "OK":
                manifest += f"> **ALERT**: {health.get('message', 'Unknown error')}\n\n"
            
            manifest += "**Interface and Capabilities:**\n"
            manifest += f"```text\n{tool.get_interface_description().strip()}\n```\n"
            manifest += "\n"
        
        # 3. Domain Models (Index via Core Registry)
        manifest += "## ðŸ“¦ Domain Models (Data Structures)\n"
        manifest += "Registered data structures. You can read the code directly at their path for details.\n\n"
        
        domain_metadata = registry.get_domain_metadata()
        for domain_name, data in sorted(domain_metadata.items()):
            manifest += f"### ðŸ§© Domain `{domain_name}`\n"
            for key in sorted(data.keys()):
                if key.startswith("model_"):
                    model_name = key.replace("model_", "")
                    manifest += f"- Available model: `{model_name}`\n"
            manifest += "\n"

        # 4. Write the file
        try:
            with open("AI_CONTEXT.md", "w", encoding="utf-8") as f:
                f.write(manifest)
            print("[ContextTool] AI_CONTEXT.md updated via Core Registry.")
        except Exception as e:
            print(f"[ContextTool] Error writing manifest: {e}")