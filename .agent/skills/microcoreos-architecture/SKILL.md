---
name: microcoreos-architecture
description: Ensures adherence to MicroCoreOS "Atomic Microkernel" architecture. Use when creating or modifying core, tools, plugins, or domains.
---

# MicroCoreOS Architecture Skill

This skill enforces the modular, asynchronous, and resilient design principles of MicroCoreOS.

## ğŸ›ï¸ Philosophy: The Sacred Core
The Core (`/core`) is the immutable heart of the system.
- **Kernel**: Orchestrator for non-blocking startup and DI.
- **Container**: Thread-safe registry (`RLock`) for observability.
- **Registry**: Structural inventory of tools, domains, and plugins.
- **Base Components**: System contracts (`BaseTool`, `BasePlugin`).

**Golden Rule**: Files in `/core` are **SACRED**.
- NEVER modify them for business logic, tracing, or health checks.
- Intelligence grows in Plugins and Tools.
- For observability, use the `event_bus` or `registry` from a dedicated Plugin.

## ğŸ—ï¸ Development Rules

### Plugins & Models
1.  **Isolation**: Communication between domains MUST be via `event_bus`. No cross-domain imports.
2.  **Location**: 
    - Plugins: `domains/{domain}/plugins/`.
    - Models: `domains/{domain}/models/`. (Auto-discovered as metadata).
3.  **Single-File Clean Architecture**: Each plugin MUST be contained within a single file. Logic, validation, and execution flow should NOT be split.
4.  **Sovereign Validation**: Use Pydantic models for API schemas and static methods in the `UserModel` for business validation.
5.  **Return Format**: Always return `{"success": bool, "data": ..., "error": ...}`.
6.  **Tool Type Hinting (QoL)**: Use `if TYPE_CHECKING:` and string type hints (e.g., `'HttpServerTool'`) in `__init__` EXCLUSIVELY to provide the agent and IDE with autocomplete for Tools. Since there are no cross-domain imports, circular dependencies are impossible by design.

### Communication & Events
**The Golden Guard**: Communication between domains is **STRICTLY EVENT-DRIVEN**.
- **No Cross-Imports**: Plugins MUST NOT import from other domains.
- **Event Standards**: 
    - Use `event_bus.publish(name, data)` for fire-and-forget side effects.
    - Use `event_bus.request(name, data)` ONLY for mandatory cross-domain queries.
    - Successful state changes (e.g., `user.created`) MUST be published.

### Tools & Discovery
Before interacting with any infrastructure:
1.  **Mandatory Context Check**: Read [AI_CONTEXT.md](../../../AI_CONTEXT.md). This file is the "Live Manual" generated by the Kernel.
2.  **Tool Signatures**: Copy exact method names and parameters from the `Available Tools` section of the context.
3.  **Deep Inspection**: If a tool's behavior is unclear, view its implementation in `tools/{tool_name}/`.
4.  **Injection**: Request the tool by its name in your plugin's `__init__`.

### Advanced Standards
- **API Schema**: When using `http_server.add_endpoint`, always provide `request_model` and `response_model` using Pydantic classes from your domain models.
- **Side Effects**: Successful state changes MUST publish an event via `event_bus.publish("domain.event_name", data)`.
- **Tool Lifecycle**: 
    - `setup()`: Internal tool initialization.
    - `on_boot_complete(container)`: Actions that require the full system to be online.

### Step-by-Step for Creating a Plugin
1.  **Identify Domain**: Determine the target domain.
2.  **Consult Context**: Read `AI_CONTEXT.md` for tool availability.
3.  **Create Model**: Define Pydantic schemas in `domains/{domain}/models/`.
4.  **Implement Plugin**: Create the class in a single file, using `TYPE_CHECKING` guards for DI.
5.  **Register & Execute**: In `on_boot`, register endpoints with schemas. In `execute`, follow Validate -> Process -> Act -> Respond.

## ğŸ“‚ Supplementary Information
For detailed agent persona and behavioral refinement, refer to [agent.md](./agent.md).
